# PROCESS

### 프로세스는 메모리 위에 적재된 프로그램임. 메모리 위에!

# Program Counter

프로그램 카운터(Program Counter, PC)는 컴퓨터 시스템의 중앙 처리 장치(CPU)에서 현재 실행 중인 명령어의 위치를 가리키는 레지스터입니다. 

프로그램이 실행될 때 CPU는 메모리에 저장된 명령어를 순차적으로 가져오며, 프로그램 카운터는 다음에 실행할 명령어의 주소를 저장합니다.

주요 기능은 다음과 같습니다:

•	**명령어 주소 저장:** 현재 실행 중인 명령어 다음에 실행할 명령어의 메모리 주소를 유지합니다.

•	**자동 증가:** 명령어가 실행될 때마다 프로그램 카운터는 자동으로 증가하여 다음 명령어의 주소를 가리킵니다.

•	**점프 및 분기 처리:** 프로그램에서 분기(조건문 등)가 발생하면 프로그램 카운터는 해당 분기 명령어에 의해 지정된 주소로 업데이트됩니다.

즉, 프로그램 카운터는 프로그램의 흐름을 관리하는 중요한 역할을 합니다.

# Layout of Process (중요)

- Text Section

→ executable code (실행 코드)

- Data Section → 글로벌 변수

→ Global Variables 

- Heap Section → 메모리

→ Memory Dynamically Allocated (메모리 담기)

- Stack Section (함수 실행)

추가적으로

프로세스는 여러개 생길수 있고, 프로세스가 실행중인데 다른 프로세스 또한 실행이 가능함

1.	**텍스트 (Text) 섹션: 실행코드 저장장소**

•	**설명:** 프로그램의 실행 코드가 저장되는 영역입니다. CPU가 실제로 실행할 명령어들이 이곳에 위치합니다.

•	**특징:** 일반적으로 읽기 전용이며, 메모리에서 가장 작은 공간을 차지합니다.

2.	**데이터 (Data) 섹션: 변수 저장장소**

•	**설명:** 전역 변수, 정적 변수와 같은 초기화된 데이터가 저장됩니다.

•	**특징:** 프로그램이 실행되는 동안 값을 유지하며, 읽기 및 쓰기가 가능합니다.

3.	**힙 (Heap) 섹션: 동적할당 메모리 저장장소**

•	**설명:** 동적으로 할당된 메모리(예: malloc 함수로 할당되는 메모리)가 저장됩니다.

•	**특징:** 프로그램 실행 중에 크기가 증가하거나 감소할 수 있으며, 메모리 할당과 해제를 통해 관리됩니다.

4.	**스택 (Stack) 섹션: 함수의 관한 정보 저장장소**

•	**설명:** 함수 호출 시 지역 변수, 함수의 매개변수, 리턴 주소 등이 저장되는 메모리입니다.

•	**특징:** 함수가 호출될 때마다 스택에 메모리가 추가되며, 함수가 종료되면 스택에서 메모리가 해제됩니다. Last In, First Out(LIFO) 방식으로 관리됩니다.

# Process 상태 (중요)

특정 사이클이 존재함

New → ready → running → Waiting → Ready → ..

끝나면 Terminated

- New : 프로세스가 만들어지고 있는 상태
- Running : Instruction이 실행되고있는 중 (실행상태)
- Waiting : 프로세스가 이벤트의 실행을 기다리고 있는 상태 (대기상태)
- Ready : 실행될 준비갈 완료
- Terminated : 프로세스가 실행이 끝난것.

•	**New → Ready**: 프로세스가 생성되고 초기화된 후, 준비 상태로 전환됩니다.

•	**Ready → Running**: 스케줄러에 의해 선택되어 CPU를 할당받으면 실행 상태로 전환됩니다.

•	**Running → Waiting**: 프로세스가 I/O 요청이나 자원 요청을 할 때 대기 상태로 전환됩니다.

•	**Waiting → Ready**: 요청한 이벤트가 완료되면 준비 상태로 돌아옵니다.

•	**Running → Terminated**: 프로세스가 실행을 완료하고 종료 상태로 전환됩니다.

프로세스를 내가 메인메모리에 올리려했는데 여건이 안돼서 대기공간에 들어가 → new

대기 완료 → ready 할강준비 긑!

cpu 할당 기회를 기다리고있다가 찾아오 -? running 

cpu 작업은 빠르고 명령문은 느려, 따라서 다른이벤트 중이면 대기 → waiting

대기하다가 그 이벤트가 끝나면 running

위 싸이클이 반복되다가 일이 끝나면 terminated

![스크린샷 2024-09-29 오후 5.56.04.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/900777d9-ab90-4aef-98c2-c85b23fb93b9/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.56.04.png)

# PCB ( process control block) <상아카페메스케>



1.	**프로세스 상태 (Process State):**

•	프로세스가 현재 실행 중인지, 대기 중인지, 종료되었는지 등의 상태 정보를 저장합니다.

2.	**프로세스 ID (PID, Process ID):**

•	각 프로세스를 식별하는 고유한 ID입니다.

3.	**프로세스 카운터 (Program Counter):**

•	프로세스가 다음에 실행할 명령어의 주소를 가리킵니다.

4.	**레지스터 (Registers):**

•	CPU 레지스터 값(명령어 수행에 필요한 데이터)을 저장합니다. 여기에는 누산기, 인덱스 레지스터, 스택 포인터 등이 포함됩니다.

5.	**메모리 관리 정보 (Memory Management Information):**

•	프로세스가 사용하는 메모리 공간에 대한 정보입니다. 페이지 테이블, 세그먼트 테이블 등의 메모리 구조 정보가 포함됩니다.

6.	**CPU 스케줄링 정보 (CPU Scheduling Information):**

•	우선순위, CPU 점유 시간 등의 스케줄링 관련 정보입니다.

7.	**입출력 상태 정보 (I/O Status Information):**

•	프로세스가 사용 중인 입출력 장치, 열려 있는 파일 목록 등의 정보를 포함합니다.

8.	**Accounting Information (회계 정보):**

•	**설명:** 프로세스가 사용한 자원에 대한 정보를 저장하는 부분입니다.

•	**내용:** CPU 사용 시간, 프로세스가 소비한 메모리 용량, 실제 실행 시간, 사용된 입출력(I/O) 장치 등에 대한 통계를 포함합니다.

•	**용도:** 주로 프로세스의 자원 사용 추적, 과금(Chargeback) 시스템, 성능 분석 및 최적화 목적으로 사용됩니다.

# Process Scheduling

### 배경

운영체제에서 **프로세스들을 CPU에 할당하여 실행 순서를 결정하는 메커니즘**입니다. 

다중 프로그래밍 환경에서는 여러 프로세스가 동시에 실행되기를 원하지만, CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 효율적인 스케줄링이 필수적입니다.

## Degree of Mulitprogramming

현재 메모리에 올라와있는 프로세스 수.

## 스케쥴링은 프로세스의 종류에 따라 균형을 맞춰줘야하는데..

- 결론적으로 i/o 가 짧은 계산을 하며 긴 작업
- cpu-bound 긴 계산을 하며 입출력 작업은 적음

i/o bound process (many cpu call ( short cpu bursts

cpu bound process(Long cpu bursts)

**1. I/O 바운드 프로세스 (I/O Bound Process)**

•	**설명:** I/O(입출력) 작업이 많이 발생하는 프로세스입니다. 즉, **입출력 장치**(디스크, 네트워크, 프린터 등)에서 데이터를 읽거나 쓰는 작업이 주로 수행됩니다.

•	**특징:**

•	CPU에서 **짧은 계산**을 수행한 후, **긴 I/O 작업**을 기다립니다.

•	I/O 작업이 완료될 때까지 CPU가 대기해야 하므로 **대기 시간이 긴** 경우가 많습니다.

•	자주 **입출력 작업**을 요청하기 때문에 **CPU 사용률**은 낮고, **I/O 장치 대기 시간이** 길어집니다.

**2. CPU 바운드 프로세스 (CPU Bound Process)**

•	**설명:** 주로 **계산**이나 **연산 작업**이 많이 발생하는 프로세스입니다. CPU에서의 **처리 작업**이 많아 상대적으로 입출력 작업이 적습니다.

•	**특징:**

•	CPU에서 **긴 계산**을 수행하며, **I/O 요청**은 적습니다.

•	CPU에 대한 의존도가 높아 **CPU 사용률**이 매우 높습니다.

•	프로세스가 계산을 마칠 때까지 **CPU에서 오래 실행**되기 때문에, I/O에 비해 CPU 자원을 많이 사용합니다.

# Scheduling Queues

- Ready Queues → main memory에다가 set all process

→ CPU바운드가 대기하는 놈

wait for CPU core

(메모리에 올라와서 실행대기)

- Wait Queues → waiting for certain Event IO- > 바운드 마다?

Completion of I/O (입출력완료)

특정 이벤트를 기다리는놈.. cp

•	**레디 큐:** 프로세스가 **즉시 실행될 준비가 완료된 상태**에서 CPU 할당을 기다리는 큐.

•	**웨이트 큐:** 프로세스가 **I/O 작업이나 특정 이벤트**가 완료되기를 기다리는 상태에서 대기하는 큐.

1	**레디 큐**: CPU 바운드 프로세스는 이 큐에서 CPU 할당을 기다립니다.

	**Running**: CPU를 할당받아 작업을 수행합니다.

	**Running → Waiting**: I/O 작업이 필요할 경우, 프로세스는 웨이트 큐로 전환됩니다.

	**Waiting → Ready**: I/O 작업이 완료되면 프로세스는 다시 레디 큐로 돌아옵니다.

5.	이 과정을 반복하면서 CPU와 I/O 자원을 효율적으로 사용하게 됩니다.

![스크린샷 2024-09-29 오후 6.31.16.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/d0981e7f-2a35-465d-8231-197ec31414ad/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.31.16.png)

### Swapping

메모리에 있는 프로세스들 몇개를 제거하는것

# Context Switch

context는 프로세스가 작업했던 상태를 의미함 (옛날 프로세스)

## CPU가 프로세스를 바꾸면 ?

시스템은 그 전에 상태를 저장해야함 (STATE SAVE)

+

load the saved state for the new process(STATE RESTORE)

새로운 놈도 옛날에 한번 거친놈이라 그의 저장한 상태를 복원해야함

# Process Creation

부모 프로세스가 자식 프로세스를 만들수있다는 개념.

PID를 통해 관리됨

**1. fork()**

•	**목적:** 새로운 프로세스를 생성합니다.

•	**동작:**

•	현재 프로세스의 복사본을 만듭니다.

•	부모 프로세스와 자식 프로세스는 동일한 코드와 데이터를 공유하지만, 각각 독립적으로 실행됩니다.

•	**PID**(프로세스 ID)는 새로운 자식 프로세스에 할당되며, 부모 프로세스와 자식 프로세스는 서로 다른 프로세스입니다.

**2. exec()**

•	**목적:** 현재 프로세스의 실행 내용을 변경하여 새로운 프로그램을 실행합니다.

•	**동작:**

•	현재 프로세스의 메모리 공간을 새로운 프로그램의 코드로 완전히 대체합니다.

•	프로세스의 **PID**는 유지되지만, 기존 프로세스의 코드와 데이터는 사라지고 새로운 프로그램의 코드가 실행됩니다.

**요약**

•	fork()는 **새로운 프로세스**를 만들고, exec()는 **새로운 프로그램**을 실행하여 기존 프로세스의 실행 내용을 변경합니다. 일반적으로 fork()로 새로운 프로세스를 생성한 후, 그 자식 프로세스에서 exec()를 호출하여 새로운 프로그램을 실행하는 방식으로 사용됩니다.

## fork() + exec()

**1. fork() → 새로운 프로세스 만들기**

•	**기능:** 현재 프로세스의 복사본을 생성하여 새로운 자식 프로세스를 만듭니다.

**2. exec() → 완전히 새로운 프로그램으로 대체**

•	**기능:** 현재 프로세스의 메모리 공간을 새로운 프로그램으로 대체합니다.

# Process Termination

종료도 실행과 마찬가지로 시스템콜을 통해 요청

## Use exit() Call (정상종료)

정상 종료

return status data form child to parent

## abort() call. (비정상 종료)

자식의 프로세스의 일이 필요없거나 과열

부모가 만약 비정상종료가 되었다면 자식은 아래와 같은 녀석이 될수있는 가능성이있다.

좀비 프로세스  → 자식이 종료가 되었는데 부모가 종료되지 않을때 (wait()를 호출하지 않을때)

혹은 

고아 프로세스 가 → 부모가 wait() 하지않고 종료 

### wait() call

자식이 종료될때까지 기다림 부모프로세서가

# Interprocess Communication

 서로 다른 프로세스 간에 데이터를 전송하거나 정보를 교환하는 방법을 의미.

실행 중인 여러 프로세스는 각기 독립적으로 메모리 공간을 가지고 있으며, 이로 인해 데이터 공유가 필요할 때 IPC를 사용합니다.

 IPC는 다양한 방법으로 구현될 수 있으며, 각 방법은 특정한 상황이나 요구에 따라 적합할 수 있습니다.

## Shared Memory (중요)

![스크린샷 2024-09-29 오후 7.00.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/ac46e3cd-105d-436f-a43a-190ded5e915f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.00.17.png)

장점 : 프로세스들이 메모리 공간을 공유 (커널 개입도 없음) : 빠르고, 오버헤드가 적음 , 다량 데이터 가능

단점 : 동기화 문제 (여러 프로세스가 동시에 접근하면 복잡해짐), 보안 (공유니까)

## Msg Passing

공유 메모리가 필요 없음 

- 작은 데이터를 주고받을때
- 큐에 저장하고 가져가
- 프로세스는 신경쓸게 전혀없음
- 운영체제가 지속적 개입

장점 : 안정하며 보안 (운체가 계속 개입하므로)

단점 : 느림, 오버헤드ㅠ

# 생산자-소비자 문제

두개의 프로세스가 메모리를 가지고 협업을 할때는 데이터를 갖고 작업을 한다.
bounded올려놓는 곳 + 먹는 사람이 있는 것처럼.. 비슷한 느낌이라고 생각
둘 중 하나가 다 떨어지면 누구는 대기 해야한다

생산자 : 데이터를 생성
소비자 : 데이터를 소비

unbounded buffer-> 는 제한이 없고
bounded buffer-> 제한이 있지만 ( 이걸 많이 씀)

### Shared Buffer (bounded Buffer)

### #1. 버퍼사이즈는 10이지만 하나를 비워야한다.

![스크린샷 2024-09-29 오후 7.02.21.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/59c7af2a-105f-408b-9f77-144e80a79c45/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.02.21.png)

#2. 원형 배열 형태임 (in 생산자 넣어야하니 , out 소비자 빼야하니)

## 생산자 입장에서

#3. in+1 = out이란 뜻은 원형 배열이 꽉차있다는 소리니 생산불가 . 대기

![스크린샷 2024-09-29 오후 7.02.42.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/afcec27a-1e20-4292-8cf5-7edc4772fcf7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.02.42.png)

## 소비자 입장에서 (out의 입장)

#4.in ==out 이면 먹을게 없다는 뜻이니 소비자 입장 대기

![스크린샷 2024-09-29 오후 7.03.25.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/6442b3fd-5811-4cb9-8071-b41a1e5cd671/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.03.25.png)

# 메세지 파싱

## 커뮤니케이션 링크가 무조건 있어야함 그래야 가능

### Direct Communication (중요)

send , receive를 활용

→  딱 두개의 프로세스만 끼리만 가능

### 오직 두개만 !! 하나의 링크밖에 없는..

### InDirect Communication

MailBox (Port) 가 무지 정확해야함

메일박스는 고유의 아이디를 지니고있다. 

### 포트는 공유될수있음

### 링크 또한 여러개일수 있다.

### MailBox Sharing이라고도 하죠.

# 동기화

## Blocking  == synchronous

send 하면 receive할때까지 대기


### blocking Send - 전송자가 막아놔 msg가 받기 전까지

### blocking Receive - 수송자가 막아놔 msg 보내기 전까지 (blocked!)

## Non Blocking ==  asynchronous



# 요약

- Process = Program in execution
- Process is represented by program counter
- Process의 section
- → Text, data, heap, stack
- process의 상태변환!
- → ready, running, waiting, terminated
- PCB ( 프로세스 표현을 위한 DATA STRUCTURE) (프로세스 사령탑) (엄청난 정보가 담겨있)
- Process scheuduler는 CPU에서 run될놈 찾기
- Context Switch( cpu 프로세스가 바뀔때마다) state restore & state save
- fork() (new process 생성)
- Shared Memory → 매우 빠르고 운체 개입없지만 동기화 책임, 보안
- msg passing → 저 반대

**1. Shared Memory**

•	**설명:** 여러 프로세스가 동일한 메모리 공간에 접근하여 데이터를 공유하는 방법입니다.

**장점:**

•	**속도:** 데이터 전송이 메모리 접근을 통해 이루어지기 때문에 매우 빠릅니다. 데이터를 복사할 필요가 없어 성능이 향상됩니다.

•	**대량 데이터 처리:** 대량의 데이터를 처리할 때 유리합니다. 여러 프로세스가 동시에 큰 데이터를 읽고 쓸 수 있습니다.

**단점:**

•	**동기화 필요:** 여러 프로세스가 동시에 공유 메모리에 접근하기 때문에 데이터의 무결성을 보장하기 위해 동기화(세마포어, 뮤텍스 등)가 필요합니다. 이는 복잡성을 증가시키고 성능을 저하시킬 수 있습니다.

•	**초기화 및 관리:** 공유 메모리를 설정하고 관리하는 데 추가적인 작업이 필요합니다.

**2. Message Passing**

•	**설명:** 프로세스 간에 메시지를 주고받는 방법으로, 각 프로세스는 독립적인 메모리 공간을 유지합니다.

**장점:**

•	**간단한 설계:** 프로세스가 서로 독립적으로 실행되므로, 데이터 충돌이나 무결성 문제를 피할 수 있습니다. 동기화 문제가 줄어듭니다.

•	**유연성:** 네트워크를 통한 통신이 가능하여 분산 시스템에서도 사용될 수 있습니다. 서로 다른 시스템 간에도 메시지를 주고받을 수 있습니다.

**단점:**

•	**속도:** 메시지 전송 시 데이터가 복사되므로, 성능이 저하될 수 있습니다. 특히 빈번한 메시지 전송이 필요한 경우에는 성능이 문제가 될 수 있습니다.

•	**제한된 대역폭:** 메시지 큐의 크기나 시스템 자원에 의해 제한될 수 있습니다.

**결론**

어떤 방식이 더 좋은지는 다음과 같은 요소에 따라 달라질 수 있습니다:

1.	**성능:** 대량의 데이터를 빠르게 공유해야 하는 경우 **Shared Memory**가 유리합니다.

2.	**안정성 및 관리:** 서로 독립적인 프로세스 간의 통신이 필요하고, 동기화 문제를 피하고자 할 경우 **Message Passing**이 적합합니다.

3.	**시스템 아키텍처:** 분산 시스템에서는 **Message Passing**이 더 적합할 수 있습니다.

결국, 선택은 특정 애플리케이션의 요구 사항, 성능 요구, 시스템 아키텍처 및 프로세스 간의 관계에 따라 달라집니다. 필요에 따라 두 가지 방법을 조합하여 사용하는 경우도 많습니다.

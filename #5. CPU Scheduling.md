# 기본적인 개념

### 이게 먼데요 스케쥴?

하나의 CPU 는 오직 하나의 프로세스만을 실행함

### 나머지는요

CPU가 프리해질때까지 기다려야함

CPU가 이제 프로세스를 실행하고 다른거 실행을 한다했을때 어떤거를 선택할건가? 이것이 기본개념임

# CPU 입출력 버스트 사이클

### 프로세스 실행은 CPU 실행 + 입출력 대기 사이클로 구성

![스크린샷 2024-10-14 오전 10.00.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/bfbc503d-572d-4f77-a67e-20dfc23c1000/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.00.02.png)

위의 그림을 보면 CPU brust 상태는 프로세스의 명령어를 수행하는 상태이고 

I/O burst 상태는 프로세스가 사용자로부터 입력받기를 기다리거나 명령어 수행 결과를 출력하는 상태입니다.

# I/O Burst에선.. 낭비가 일어날수있음

CPU는 일단 대기를 함 근데 이건 너무 낭비임’

따라서

일반적으로 입/출력 중심의 프로그램은 짧은 CPU burst를 가질 것입니다

 반대로 CPU 지향 프로그램은 긴 CPU burst를 가질 것입니다. 아래 그림은 burst 지속 시간에 따른 입/출력의 빈도수를 표현한 그래프입니다.

cpu burst 시간에 따른 입출력 빈도수

cpu burst 시간이 길어지면 입출력 빈도수 적어짐

![스크린샷 2024-10-14 오전 10.03.50.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/664ec4d2-c376-4354-bd0b-2a128e9480fa/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-14_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_10.03.50.png)

# CPU 스케쥴러

cpu가 쉴때마다 os가 준비 완료 큐에있는 프로세서들 중 하나 선택 후 시행

### 선택 절차는 없나요 (프로세스를 선택

short term 스케쥴러 ( or CPU scheduler)에 의해 수행됌

스케쥴러는 ready가 되있는 메모리내 프로세스를 선택후 cpu에게 할당

### 큐는 요

- FIFO
- 우선순위 큐

### 정리하자면..

**CPU 스케줄러는 실행 준비가 되어 있는 프로세들 중에서 하나를 선택하여 CPU에게 할당해주는 역할을 수행함**

# 선점 스케쥴링 vs 비선점 스케쥴링


### 비선점 스케쥴링 (Non-Preemptive Scheduling)

대기 스제큘링

비선점 스케줄링은 CPU가 현재 실행중인 프로세스가 완료될때까지 다른 프로세스들은 대기하는 스케줄링을 의미합니다.

 오직 현재 실행중인 프로세스가 종료되거나 입/출력을 위하여 대기 상태(wating state)로 들어가는 경우에만 다른 프로세스들이 실행할 수 있습니다.

### 선점 스케쥴링(preemptive Scheduling)

CPU가 현재 프로세스를 실행중일때 스케줄러에 의해 현재 프로세스의 CPU 제어권을 다른 프로세스한테 넘기는 스케줄링을 의미

실행중인 프로세스가 다른 프로세스에게 CPU 제어권을 선점당하면 Running 상태에서 Ready 상태로 변하고 입/출력을 위하여 대기 중인 상태에서 다른 프로세스가 CPU를 선점하면 Ready 상태로 전환

### 몇가지 상황에서의 CPU 스케쥴링 결정(중요)

준비

running → waiting

1. 한 프로세스가 실행 상태에서 대기 상태로 전환 될 때(예를 들어, 입/출력 요청 등)
2. 프로세스가 실행 상태에서 준비 완료 상태로 전환 될 때(예를 들어 다른 프로세스의 인터럽트 발생)
3. 프로세스가 대기 상태에서 준비 완료 상태로 전환 될 때(예를 들어, 입/출력의 종료)
4. 프로세스가 종료할 때

1,4번 상황에서만 스케줄링이 발생한 경우 비선점 스케줄링입니다. (대기 전환, 종료 ) → 비선점

나머지는 알아서.

 2,3번 상황에서 스케줄링이 발생한 경우 비선점 스케줄링을 할수도 있고 선점 스케줄링을 할 수 있습니다.

running →에서 가는건 비선점

# Dispatcher? → cpu 제어를 스케쥴러가 하게끔

cpu 스케쥴링 기능에 포함된 요소, 스케쥴러가 하는 일 중 하나임.

선정된 프로세스가 바로 작업을 할수있도록 준비시켜줌

- Context Switching
- User Mode 전환
- 사용자 프로개름의 적절한 위치로 jump

### Dispatch latency

프로세스 바뀔때, 다른 프로세스 수행 시작까지 소요되는 대기시간 (pcb move 때 save, restore 하잖슴)

# Scheduling Criteria(스케쥴링 기준)

CPU 스케쥴링 알고리즘을 비교하기 위한 여러가지 기준

## 기준?

서로 다른 cpu 스케쥴링 알고리즘들은 다른 특성들을 가지고 있음. 

- CPU utilization (이용률) :
- Throughput(처리량) : 단위 시간당 완료된 프로세스 갯수
- Turnaround Time(총 처리시간) : 메모리에 들어가기 위해 기다리며 소비한 시간과 준비 완료 큐에서 대기한 시간, CPU에서 실행하는 시간, 입/출력 시간을 합한 시간입니다.

→ 쉽게 말하면 프로세스 제출 시간과 완료시간의 간격

- Waiting Time(대기 시간) : 준비완료 큐에서 대기하면서 보낸 시간의 합
- Response TIme(응답 시간) : 하나의 요구를 제출했다면. 이후 첫번째 응답이 나올때까지의 시간

### 즉 스케쥴링 기준은

MAX (극대화 시킨다 누구를) ? CPU Util이랑 , throughPut( 처리량)

MIN(극소화 시킨다 누구를)?  총 처리시간(turnarroun time), waitiing time, response time

# 지금까지.

스케쥴링은 준비완료에 큐에 있는 어떤 프로세스에게 CPU를 할당할건지의 문제를 다룬다.

그럼 어느 프로세스를 선택하는지로 문제로 귀결되며 

그 선택하는 방식은 CPU 스케쥴링 알고리즘에 따라 다르다.

# 스케쥴링 알고리즘 최적화 기준

또한, CPU util, throughput 극대화 + turnaround time, waitingt time, response time 극소화

가 목표

- 선입 선처리 스케줄링(First-Come, First-Served Scheduling)
- 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)
- 우선순위 스케줄링(Priority Scheduling)
- 라운드 로빈 스케줄링(Round-Robin Scheduling)
- 다단계 큐 스케줄링(Multilevel Queue Scheduling)
- 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)

# FCFS (first come, first served) <비선점>

먼저 요청하는 놈이 먼저 할당받는 간단한 구조 

당연히 선입선출 큐를 활용하겠다.

다만 평균 대기 시간이 매우 긴 단점 ( Waiting time 개 길어) 

### 대기시간 구하기

![스크린샷 2024-10-15 오후 5.46.41.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/47ae013b-7653-42c8-bd2d-9c43095e5981/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.46.41.png)

### 처리시간 구하기

![스크린샷 2024-10-15 오후 5.48.28.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/c98eb352-bfbd-4895-a243-6ac9cc6001de/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.48.28.png)

이 단점이 극단적으로 긴 한 프로세스 때문에 프로세스 도착 순서에 따라 대기시간이 팍 달라짐

### Convoy Effect

이런 현상을 콘보이 효과 (FCFS의 단점으로 꼽힘)

### FCFS 는 Non-Preemtive

# Shortest Job First. (SJF) <선점,비선점> 둘다 가능

**CPU가 이용 가능해지면, 가장 작은 다음 CPU 버스트를 가진 프로세스에게 할당**

 만약 길이가 동일하다면 선입 선처리 스케줄링을 적용합니다..

- 가장 작은 다음 CPU 버스트 프로세스에 할당 + 같다면 FIFO

![스크린샷 2024-10-15 오후 5.51.14.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/a2f53d5c-99c9-41e3-8faf-74f09029e719/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_5.51.14.png)

## 문제는.. 예측이다

어렵다 다음 CPU 요청 burst 길이를 예측하는것이니까. 쉽지 않다.

따라서 장기 cpu 스케쥴링 수준에서 구현가능

![스크린샷 2024-10-15 오후 6.00.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/f1e28c37-f9ba-42b6-a24c-35875ab51055/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.00.17.png)

.

# SJF 도 두 종류가 있다.

앞의 프로세스가 실행되는동안 새로운 프로세스가 준비 완료 큐에 도착한다면 선택이 발생한다.

그 새로운 프로세스가 현재 실행하고 있는 프로세스의 남은 시간 보다도 짧다면

선점을 할지 그대로 둘지 (비선점)할지 고민을 해야함

### Preemptive SJF  → 새로운 프로세스의 시간이 더 짧다면 선점

### → Shortest-remaining-time First (가장 짧게 남은 놈 먼저) 라는 것

### Non-Preemptive SJF → 기존에 프로세스가 일을 하게 둬

![스크린샷 2024-10-15 오후 6.03.40.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/d13c7618-3823-46f3-976e-27144f9ae078/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.03.40.png)

# Round-Robin Scheduling

 프로세스들 사이를 옮겨다니기 위해 **선점이 추가**된 스케줄링 + FCFS

## time-quantum ( 시간 할당량) 이 정해져있음

CPU 스케줄러는 준비 완료 큐를 돌면서 **한번에 한 프로세스에게 한번의 시간 할당량 동안 CPU를 할당함**

이때까지 끝내라 ! 하는 것

### 어떤 프로세스도 (n-1)q 시간 단위 이상 응답대기하지않습니다!!!!!

### 원형 큐를 활용

**시간 할당량을 정의하고 원형 큐에 프로세스들을 넣은 다음 각 프로세스에게 정의한 시간 할당량 만큼 CPU를 할당시키고 수행**시키는 스케줄링 방식입니다.

여러 프로세스의 시간 분배: 만약 준비 큐에 n개의 프로세스가 있고 타임 퀀텀 q가 설정되어 있다면, 각 프로세스는 최대 q 시간 단위로 CPU 시간을 1/n 만큼 할당받습니다. 따라서 

타이머 인터럽트: 타이머는 매 타임 퀀텀마다 다음 프로세스를 스케줄링하기 위해 인터럽트를 발생시킵니다.

성능 의존성: 성능은 타임 퀀텀의 크기에 따라 달라집니다.

q가 클 경우: FIFO(First-Come, First-Served)와 유사한 성능을 보입니다.
q가 작을 경우: q는 컨텍스트 스위칭(context switching)에 비해 충분히 커야 하며, 그렇지 않으면 오버헤드가 너무 커질 수 있습니다.

## 프로세스의 CPU 버스트가 시간 퀀텀 보다 짧다면?

1. 프로세스가 자신의 CPU를 멈춤 (끝났으니)
2. 그 후 다음 프로세스 진행

## 프로세스의 CPU 버스트가 시간 퀀텀 보다 길다면?

1. 타임 스또프 —> 인터럽트 발생!
2. Context Switch
3. 실행하던 프로세스는 준비완료큐에 꼬리에 넣어

![스크린샷 2024-10-15 오후 6.29.39.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/a96c0502-a8c5-4c2b-a095-06f377b40a8f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.29.39.png)

# 특징

라운드 로빈의 평균 대기시간은 상당히 길어질수 있다 ( 시간할당이 엄겨하니까)

대신 응답시간은 빠르게 답할수 있으니 적어지겠다. 

어떤 프로세스도 (n-1)q 시간 단위 이상 응답대기하지 않습니다.

퀀텀이 너무 짧으면 오버헤드가 커질것이고 (문맥교환 개 많아)

퀀텀이 너무 길면 응답시간이 느려지겠죠. 

또한 문맥교환 시간보다는 퀀텀이 무조건 길어져야하겠다.

# Priority Scheduling

가장 높은 우선순위를 가진 녀석이 우선이며, 우선순위가 같다면 FCFS의 방식

### 우선순위의 기준?

CPU 버스트 시간 짧은 놈이 우선을 갖는다.

![스크린샷 2024-10-15 오후 6.25.24.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/65bbeb2e-2437-4ab8-a58e-e5711eeba2b1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.25.24.png)

### 우선순위 스케쥴링 또한 선점/비선점 으로 나눠짐

새로 도착한 프로세스의 우선순위를 현재 실행중인 프로세스의 우선순위와 비교합니다. 

선점형 우선순위  스케줄링 알고리즘은 새로 도착한 프로세스의 우선순위가 현재 실행되는 프로세스의 우선순위보다 높다면 CPU를 선점합니다.

 비선점형 우선순위 스케줄링 알고리즘은 단순히 준비 완료 큐의 머리 부분에 새로운 프로세스를 넣습니다. 

### 문제점 ! <Starvation> 발생!

만약 우선순위가 낮다면 얘는 무한봉쇄 혹은 기아 상태  무한대기 혹은 선택받지 못해

## 해결! <Aging>

오래 시스템에서 대기하는 프로세스들의 우선순위를 점진적으로 증가시키는 기법입니

# MultiLevel Queue Scheduling

**다단계 큐 스케줄링 알고리즘은 준비 완료 큐를 다수의 별도의 큐로 분류하여 수행하는 방식**

즉 준비완료큐를 여러개 만드는것이야.

<ForeGround> -최전방 (라운드 로빈이 맞아)

<backGround> - 최후방(FCFS)

## 방식 설명

프로세스의 우선순위 혹은, 프로세스 유형(포어그라운드, 백그라운드)과 같은 특성에 따라 다수의 큐 중 한 개의 큐에 영구적으로 할당

포어그라운드 (문맥교환이 많고, 응답시간이 빨라야할 경우) RR을 쓰겠고

백그라운드(정적인것들은) FCFS를 쓰잖냐

이렇듯 각각 다른 특성애들을 갈라치기 하는것

### 정리하면

**다단계 큐 스케줄링 알고리즘은 프로세스들간의 우선순위를 정의하고 각 우선순위간의 큐를 생성하여 수행하는 방식**입니다. **높은 우선순위의 큐의 프로세스가 비어있지 않으면 낮은 우선순위 큐의 프로세스는 실행될 수 없습니다**

### 하지만….

<Fixed-priority preeptive scheduling>

**프로세스들은 한 큐에서 다른 큐로 이동하지 못합니다.** 왜냐하면 프로세들이 포어그라운드와 백그라운드의 특성을 바꾸지 않기 때문입니다. 이러한 방식은 적은 스케줄링 오버헤드가 장점이지만 융통성이 적다는 단점

따라서.. 아래가 있음 ㅋ

# MultiLevel Feedback Queue Scheduling

![스크린샷 2024-10-15 오후 6.40.22.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/9fcbd26a-8d39-4ce9-afe4-747c57280e1b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_6.40.22.png)

다단계 피드백 큐 스케줄링 알고리즘에서는 프로세스가 큐들 사이로 이동하는 것을 허용합니다. 아이디어는 다음과 같습니다.

 프로세스들을 CPU 버스트 성격에 따라 구분합니다. 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 낮은 우선순위의 큐로 이동됩니다

오래걸리면 자꾸 내린다 이거네(우선순위가 낮은 FCFS 큐로)

# 경쟁범위

### 프로세스-경쟁 범위 (PCS) 쓰레드끼리의 경쟁

다대일 혹은 다대다 모델에서는

쓰레드 라이브러리가 사용자 수준 쓰레드를 가용한 LWP(Light Weight Process) 상에서 스케줄링

**동일한 프로세스에 속한 쓰레드들 사이에서 CPU를 경쟁**

이 경쟁구조가 PCS

### 시스템-경쟁 범위 (SCS) cpu상에서 커널 끼리의 경쟁

 **CPU 상에서 실행되기 위해서는 운영체제가 커널 쓰레드를 물리적인 CPU로 스케줄하는 것을 필요로 합니다.** 따라서 **CPU 상에 어느 커널 쓰레드를 스케줄할 것인지 결정하기 위해서는 커널은 시스템-경쟁 범위(system-contention scope, SCS)를 사용**

![스크린샷 2024-10-15 오후 9.04.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/537c6957-75cd-4a31-84cb-f6451531db6c/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-15_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.04.17.png)

# Multi-Processor Scheduling

1.	**단일 프로세서 환경**

•	하나의 프로세서만 있기 때문에 **프로세스 스케줄링이 순차적**으로 수행됩니다.

•	**우선순위 스케줄링**, **FCFS**, **SJF**, **Round Robin**과 같은 알고리즘이 **프로세스의 순서**를 정하는 데 중점을 둡니다.

•	예를 들어, 우선순위 스케줄링에서는 **가장 높은 우선순위의 작업이 완료된 후에 다음 작업**을 처리합니다.

2.	**다중 프로세서 환경**

•	여러 프로세서가 동시에 작업을 처리할 수 있으므로 **부하 분산(Load Balancing)**이 중요합니다.

•	멀티프로세서에서는 각 프로세스가 **어떤 프로세서에서 실행될지**를 결정해야 합니다.

•	**글로벌 큐** vs. **로컬 큐** 방식이 사용됩니다.

•	여러 프로세서 간 **우선순위 충돌**이나 **스레드 이동**에 따른 **동기화 문제**가 추가됩니다.

## 그렇다면 다중 처리기 시스템에서는 어케하나요

- 비대칭 다중 처리(asymmetric multiprocessing)
- 대칭 다중 처리(symmetric multiprocessing, SMP)

2가지의 방식이 존재

### 비대칭 다중 처리(asymmetric multiprocessing)

하나의 처리기가 모든 스케쥴링 결과 입/출력 +  이동을 취급하게

다른 처리기들은 사용자 코드만 수행

**자료 공유의 필요성을 배제 (간단) 스루!**

### 대칭 다중 처리(symmetric multiprocessing)SMP SMPSMP !!

각각 처리기가 독자적으로 스케쥴링

각 처리기의 스케줄러가 준비 완료 큐(공동의 준비 완료 큐 or 처리기마다 가지고 있는 준비 완료 큐)를 검사해서 실행할 프로세스를 선택하여 수행

공통의 레디큐가 있고 , 각각 개인 스레드의 큐가 있음

## 주의점

- 두 처리기가 같은 프로세스를 선택하지 않도록 해야함
- 프로세스들이 큐에서 사리지지 않도록 보장해야함
- 여러개의 처리기가 공동 자료 구조에 접근하여 갱신한다면 스케줄러는 신중하게 프로그램되어야함

# 하나의 코어는 하나의 일만을 한다?

•	**하나의 코어**는 한 번에 하나의 명령어만 처리할 수 있습니다.

•	다만, 현대 CPU는 **컨텍스트 스위칭**과 **SMT**를 통해 여러 스레드/프로세스를 빠르게 번갈아가며 실행하여 **병렬 처리가 이루어지는 것처럼 보이게 합니다**.

•	진정한 병렬 처리는 여러 **물리적 코어**가 있을 때 가능합니다. 예를 들어, **4코어 CPU**는 동시에 **4개의 프로세스**를 실행할 수 있습니다.

# 멀티코어 프로세서

탄생 배경 : 코어가 속도빠른데 메모리 배달 속도는 느려 그래서  코어안에 하드웨어 쓰레드를 만들어놓은거

즉 속도차이->>> ( 이게 멀티코어 가 만들어진 이유… )

- Multireaded processing cores

→ 하드웨어 스레드가 있어서 코어와 속도 차이를 벌림( Memory stall) 이라는 속도 지연

- CMT ( Chip Multireading)

⇒ 하드웨어 칩 많은거 

# 스케쥴링 두 단계

소프트웨어 스레드 선택 (1단계):

각 하드웨어 스레드(논리 CPU)에서 실행할 소프트웨어 스레드를 선택합니다.
하드웨어 스레드 선택 (2단계):

어떤 하드웨어 스레드를 실행할지를 결정합니다.
RR 알고리즘: 라운드 로빈(Round Robin) 방식으로 스케줄링합니다.
각 하드웨어 스레드에 동적 긴급성(dynamic urgency) 값을 할당하여

# Load Balancing

cpu가 너무 많은 경우 

### Smp (시메트릭멀티프로세싱)의 방법론에서

1. 각각의 큐를 활용하는

각각의 큐가 

1. 공동의 큐를 활용한는 

이 두가지가 있다했다

여기서 공통의 큐를 활용한다면 크게 상관없겠다 각각 큐에서는 치우쳐질수있음

### **SMP 시스템의 모든 처리기 사이에 부하가 고르게 배분되도록 시도하는 것**

각각 큐일떄 필요하겠다 누구에게 쏠릴 가능성이있따

즉 자기 자신만의 큐를 가지고 있는 시스템에서만 필요함

## 두가지의 방식

1. Push migration → 놀고있는 놈에게 Push
2. pull migaration → 너무 바쁜놈껄 pull

# Processor Affinity ( how to handle load balance?)

프로세서 친화성

- SOFT Affinity → 로드발란스를 당하면 코어(프로세서)를 옮기는 것을 허용
- Hard Affinity  → 로드발란스 자체를 제한해버림

# Heterogeneous MultiProcessing

이종 멀티프로세싱


### Heterogenous의 뜻은 먼데요

**Heterogeneous**는 **서로 다른 종류나 성질을 가진 것들이 섞여 있는 상태**를 의미하는데요



### 왜요?

프로세서를 다양한 유형을 활용합니다

CPU + GPU

빅 코어 

리틀 코어로 나누는데요

빅 코어는 user interaction같이 무거운 거 돌리는놈

리틀 코어는 백그라운드

나누면 소모가 줄여집니다 

# Real-Time CPU scheduling

## 일단 지연 처리

인터럽트 지연 (Interrupt Latency):

정의: 인터럽트가 발생한 시점부터 해당 인터럽트를 처리하는 루틴이 시작될 때까지 걸리는 시간입니다.
디스패치 지연 (Dispatch Latency):

정의: 현재 프로세스를 CPU에서 제거하고 다른 프로세스로 전환하는 데 걸리는 시간입니다.

## SOFT Real-Time systems

반드시 언제까지 실행된다는 보장이 없는 

예를들어 멀티 레벨 큐 ( 우선순위 최우선) 이런거는 언제 실행한다는 보장이 없죠.

## Hard Real-Time systems

애는 특정한 데드라인이 존재함  <이걸 다룰건데>

### Hard Real Time -? Periodic함


주기적으로 계속 요청함

![스크린샷 2024-10-16 오후 1.09.43.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/0ed1968b-90fa-412e-9fc4-59931ed1a623/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.09.43.png)

변수 몇가지

time , deadline, period 이 세개로 다룸

## Rate Monotonic Scheduling (RMS) < At HardTime>

주기 짧은놈 위주

하지만 time / process가 높은 즉, 효율이 너무 좋으면 안돼

### 우선순위는 먼데요

주기가 짧은 놈이 우선순위를 가져갑니다. 왜요? 주기가 짧으니 만족시켜야되니까요

### 첫번째 예시

 p1 데드라인 못지켰네요

![스크린샷 2024-10-16 오후 1.11.17.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/5ce10132-6a51-4d35-91a4-d692dfc17fb1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.11.17.png)

### 두번째 예시

![스크린샷 2024-10-16 오후 1.13.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/8601bab4-a8ff-4851-8215-ecc84813693a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.13.11.png)

우선순위 지켰네요 그러니까 둘다 데드라인을 지켰슴

### 님아 근데 이거 선점 당했는데요

우선순위가 뭐라그랬죠  주기가 짧은놈이라했죠

p1은 50마다 실행되어야합니다 

p2는요 100마다요

p1이 끝나고 20부터 p2가 일하고있는데 끝나지도 않았는데 p1이 선점했습니다

왜요? 주기를 지켜야하니까요

문제 있는거 아닌가요? 그렇지는 않는게 둘다 주기를 지켰네요

### 세번째 예시 (rate monotonic한계점)

![스크린샷 2024-10-16 오후 1.15.25.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/f514ccaf-b95f-4332-9533-35e386695e79/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.15.25.png)

cpu util 이 너무 높으면 안됌 

주기가 길어 우선순위가짧아 선점당하고

 왔다갔다 하기에 주기를 못지키는 놈이 생길수있다.

![스크린샷 2024-10-16 오후 1.16.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/98bda8ce-c96a-4983-986d-8d87ff068333/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_1.16.20.png)

# EDF (Earilest DeadLine First) rate Monotic의 보완판  (각 주기마다 체크해서 누가 급한지)

아까 위의 단점 보완. 데드라인 급한 놈이 최우선권을 갖는다.

## 우선순위가 동적으로 움직인다.

![스크린샷 2024-10-16 오후 2.06.23.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/329a47e8-1d5c-4846-bed9-4fdfb10277c6/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_2.06.23.png)

즉 각각 주기마다 체크를 해서 

## 그전에 Event Latency에 대해 알아야함

### interrupt latency → 인터럽트 발생후 context swtich 전 간의 지연시간 (인터럽트 처리에 걸리는 시간)

### Dispatch latency  → 프로세서가 실행할 작업(스레드 또는 프로세스)을 선택하고 실제로 실행하기까지 걸리는 시간 (디스패치가 애초에 프로세스 를 선택 + 결정과정)

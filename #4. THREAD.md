# THREAD란 무엇인가

CPU 이용의 기본 단위. 경량 프로세스라고도 불린다. (Light Process)

일반적인 프로세스는 하나의 제어 쓰레드를 갖는데 이것은 중량 프로세스(Heavy process)

일반적으로 하나의 제어 쓰레드를 가지고 있는 중량 프로세스는 한번에 한가지의 작업만을 수행.

하지만 만약 프로세스에 여러가지 쓰레드가 존재한다면, 동시에 여러 작업을 가능

# 쓰레드는 한 프로세스 안에서 동시에 여러 작업을 수행할수 있게하는 프로세스 안의 작은 프로세스

나의 작은 아가, 쓰레드

![스크린샷 2024-10-07 오전 9.21.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/a7a6af34-e908-45a6-b0bb-c553896c8618/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-07_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.21.15.png)

# 다중 쓰레드 프로세스의 구성과 특징

쓰레드 ID, 프로그램 카운터( 다음 명령어) , 레지스터 집합, 스택으로 구성

또한 이 각각 쓰레드들은 코드,데이터, 파일을 공유함

# 왜 굳이 쓰레드를 쓰는가?

계산기를 비유하자면. 일반적인 중량 프로세스라면 평균, 최대값, 최소값을 계산하는 기능을 한개씩 순차적으로 수행한다.

그러나 여기서 쓰레드를 쓴다면 저런 몇가지의 기능을 한번에 해버릴 수 있다. (쓰레드 3개를 이용해버려서 바로 기능들을 수행)

현대의 대부분 프로그램은 쓰레드를 활용

# 장점 (중요)

크게 네가지

- 응답성(Responsiveness)
- 자원 공유(Resource Sharing)
- 경제성(Economy)
- 다중 처리기 구조의 활용(Utilization of multiprocessor architectures)

### 응답성? (continued execution allow, even 누군가 블록당해도)

대화형 응용프로그램을 다중 쓰레드화 한다했을때,

응용 프로그램이 긴 작업을 수행하더라도 프로그램의 수행이 계속되는 것을 허용

즉 사용자에 대한 응답성이 늘어난다

예를들어 웹 브라우저는 한 쓰레드가 이미지 파일을 적재하고 있는 동안, 다른 스레드에서 사용자와 일을 할수있음

### 자원공유? (shared memory or msg passing 보다 뛰어나게 스레드가 공유)

한 프로세스에 들어있는 여러가지 쓰레드들은 각자 본인이 속한 프로세스의 자원들을 공유함

### 경제성 ( cheap than context swithcing)

Context Switching 하는것이 더욱 더 저렴 그냥 쌩 프로세스로 하는거보다

### Scalability ( multiprocessor archi에서 이득을 챙길수있다) 프로그램이 여러작업을 동시에 가능 ㅇ

# Muticore Programing

### Concurrency ( 병행성) → 여러 작업이 겹쳐서 수행될수 있는.. (동시에 실행은 아님) <싱글코어>

![스크린샷 2024-10-22 오후 7.19.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/fa052903-9160-48cc-8828-b6025124b57a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.19.02.png)

### Paralleslism(병렬성) → 실제로 여러 작업이 동시에 실행

![스크린샷 2024-10-22 오후 7.19.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/70165af6-a3dd-455b-be89-6daa7b5266cf/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.19.11.png)

## 다만 멀티프로그래밍은 구현하기 쉽지 않아서..

- divideing
- balance
- data split
- data depend
- test & debug

## type of parallelism

- data parallelism → data 자체가 스플릿 된..
- task paralleism → 일 자체가 다른것 ,data는 같음
    
    

### amdahl’s law

serial ( 병렬적이지 않은 부분) 과 parallel (병렬부분)은 늘 공존한다.

병렬적이지 않은 녀석의 영역의 영향이 훨씬크다

cpu(코어가 ) 많아도 말짱 도루묵이다.

# 다중 쓰레드 모델

# User thread와 kernal thread?

- User thread는 커널 영역의 상위에서 지원되고, 일반적으로 사용자 수준의 라이브러리를 통해 구현. + 커널의 개입 없음
- Kernal thread는 운영체제에 의해 직접 지원 + 관리

# 이 둘의 연관관계

- 다대일 모델(Many-to-One Model)
- 일대일 모델(One-to-One Model)
- 다대다 모델(Many-to-Many Model)
- 다대다 모델의 변형, 두 수준 모델(Two-Level Model)

### 1. 다대일 모델 ( 제일 구림)

여러개의 사용자 쓰레드가 하나의 커널 쓰레드에 매핑

한 쓰레드가 시스템 콜(System Call)에 의해 블록(Block)이 된다면 매핑된 커널 쓰레드도 블록된 상태가 되어 전체 프로세스가 봉쇄됩니다.

하나가 막히면 다 막히는 놈

또한 하나의 사용자 쓰레드만이 커널에 접근 가능. 따라서 

다중 쓰레드가 다중 처리기에서 수행되도 병렬 작동 불가

장점 : 간단하고 효율적

단점 : one thread blocks → all block shit! + run 불가 in parallel on multicore system

![스크린샷 2024-10-07 오전 9.51.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/a88dc761-1e5a-4d5a-b706-13ded18fa8e8/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-07_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.51.11.png)

### 2. 일대일 모델

하나의 사용자 쓰레드 - 하나의 커너 쓰레드

장점 :

하나가 블록되어도 나머지는 괜찮

따라서 다중 처리기에서 병렬로 수행가능

즉 병렬성이 높아짐

단점 :

사용자 쓰레드 생성시 일대일 대응을 위해 커널 쓰레드도 생성되기에 성능저하 ㅠㅠ (오버헤드)

window, linux가 이걸씀

![스크린샷 2024-10-07 오전 9.55.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/28828d9a-c1cc-4e8b-a6a4-727ec011a629/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-07_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.55.02.png)

### 3. 다대다 모델

많은 user 스레드와 적당히 많은 kernel thread를 맞춰서 쓰는 타입

장점 : sufficient 커널 쓰레드. 굿 ㅡ, multi프로세서에서 병렬작동 가능, block 당해도 나머지 일할수있음

단점 ; 구현하기 어려움

### 4. two-model

다대다를 변형시킴

하나의 user - kernel을 종속 시킴

allows user thread bound to kernel thread

# Thread Library

쓰레드 생성과 관리를 위한 API임

### Asyncronous Threading

### JAVA Thread (runnable Interface)를 상속받아서 구현

# Implicit Threading

스레딩의 생성과 책임을 라이브러리 혹은 컴파일러에게

### 그 방법론  (쓰레드 풀, 포크 조인, open MP,

### Thread Pools

이게 뭐냐면 , 웹 서버에서 모든 요청마다 새로운 스레드를 만들어 제공한다면 시스템에는 무한한 스레드가 생성 ( 하드웨어 죽어나감)

### 장점

따라서 수영장에다가 쓰레드를 만들어 놓는것. 

존재했던 스레드를 가져다가 쓰니까 좋죠 

또한 업무 분리도 가능

### Java Thread Pools

pool객체를 만들때 필요한 코드

![스크린샷 2024-10-22 오후 7.50.00.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/ae432b27-0e2e-4ffa-9a7e-5cf0571567b3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.50.00.png)

싱글, 고정, 캐쉬드 한 ThreadPool()을 만드는 ;;

## Fork Join

1. 부모 스레드가 자식스레드를 fork 함
2. 자식 스레드의 종료를 기다리는 join을 함 

## Fork Join in Java

분할 정복 방법으로 한다요 (병합정렬, 퀵정렬마냥)

![스크린샷 2024-10-22 오후 7.53.20.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/c266a0fa-c00e-4951-b390-7131c1abac72/4b0634af-83fa-40cc-acfb-4b3e044e0c2a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-10-22_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_7.53.20.png)

begin,mid - 첫번쨰 섹션

mid+1, end - 두번째 섹션

왜요?

포크 조인은 자바에서 분할정복으로 이뤄짐  시벌

## OPen MP

#으로 시작하는 새끼다? openMP임 

C언어의 컴파일러로 하기 때문임 

## Grand Central Dispatch

맥, 애플에서 쓰이고

js로 구현되나봄

let queue =. …

### Dispatch Queue를 활용

두가지 종류

### → serial (main queue)

### → concurrent

# Threading Issue

 다중 쓰레드 프로세스를 설계할때 fork()와 exec() 시스템 콜을 사용해야 할 일이 있다면 fork()할때 부모 프로세스의 모든 쓰레드를 복사할지 말지에 대해서 고려해야 합니다.

## signal handling

다중 쓰레드 프로세스에서 신호가 발생하면 여러 쓰레드를 가지고 있는 애들에게선 너무 복잡

어느쓰레드에게 전달해야함?

### signal Canceling

- 비동기적 캔슬 (asynchronous)  → 즉각 종료
- 지연적 캔슬 (Deferred ) → 종료가 될수 있는 상태까지 연기 <자발적 종료 스스로결정>

## TLS

TLS는 멀티스레드 환경에서 **독립적인 스레드 데이터를 안전하게 관리**해야 할 때 중요한 역할을 합니다. 이를 통해 **데이터 경합 없이 병렬 프로세스를 효율적으로 관리**할 수 있습니다.

**TLS의 장단점**

•	**장점**:

•	동기화 오버헤드가 줄어듭니다.

•	각 스레드가 독립된 상태를 유지할 수 있어 안정성 확보에 유리합니다.

•	**단점**:

•	TLS를 과도하게 사용하면 메모리 사용량이 늘어날 수 있습니다.

•	스레드 종료 시 TLS 데이터 정리를 신경 써야 합니다.

**암시적 방식 (Implicit TLS)**

•	라이브러리나 런타임 환경이 TLS를 **자동으로 관리**합니다. 프로그래머가 직접 신경 쓸 필요가 없죠.

# Scheduler Activations. (중요)

얘는 사용자 쓰레드 라이버러리 와 커널 쓰레드간의 통신을 하는 방법임

응용프로그램은 커널 스레드 에 대해 정보가 없음

1. 커널이 응용 프로그램에게 LWP를 줌
2. LWP 받은 응용 프로그램은 사용자 쓰레드를 사용가능 처리기로 스케쥴링
3. 사용자 쓰레드가 수행 도중 커널은 응용프로그램에게 사건에대한 메시지를 던지는데 이게 UPCALL
4. 응용프로그램은 커널로부터 새로운 LWP 받고
5. LWP 위에서 upcall 처리

### upcall

커널이 응용프로그램에게 던지는 메세지

**비유: 식당의 주방과 손님**

•	**손님(응용 프로그램)**: 프로그램이나 사용자가 원하는 일을 요청함.

•	**서버(쓰레드 라이브러리)**: 손님의 요청을 받아서 주방에 전달하고, 결과를 다시 손님에게 가져다 줌.

•	**주방장(커널 쓰레드)**: 요청이 들어오면 실제로 요리를 만드는 핵심 작업을 처리함.

•	**주방(커널)**: 모든 재료와 도구(메모리, CPU 등)들을 관리하고, 여러 주방장들이 효율적으로 일하도록 조율함.

**실제 상황**

1.	손님(응용 프로그램)이 음식을 주문(작업 요청)하면,

→ **서버(쓰레드 라이브러리)**가 주문을 받아서 **주방장(커널 쓰레드)**에게 전달합니다.

→ 주방장들은 주방(커널)의 자원을 사용해 요리를 합니다.

2.	주방장들이 요리하는 동안,

→ 서빙 순서나 자원 배분(스레드 스케줄링)은 **주방(커널)**에서 관리합니다.

3.	요리가 완료되면 주방장들은 다시 서버에게 전달하고,

→ **서버(쓰레드 라이브러리)**가 손님에게 결과를 가져다 줍니다.

### LWP ( 경량프로세스) 는

사용자 쓰레드와 커널 쓰레드를 연결해주는 놈

둘이 연결시 , 입/출력이 완료되기를 기다리는 동안 커널쓰레드가 봉쇄되면 다같이 봉쇄

스레드 생성: 사용자 애플리케이션에서 스레드를 생성하면, 해당 스레드는 사용자 공간에서 관리됩니다.

스케줄링 요청: 사용자가 작업을 수행하고 스레드가 블로킹 상태에 들어가면, 사용자 스케줄러는 커널에 스케줄링 요청을 보냅니다.

# 요약

thread는 가장 작은 단위

멀티쓰레드 환경의 장점

1. 응답성 ( 여러 프로그램 돌려도 괜찮은)
2. resource sharing ( 프로세스보다 훨씬 깔끔하게 공유가능)
3. enonomy (저렴)
4. scalablilty(확장성) 





다만 멀티 쓰레드 -> 난이도 높음 ( 디버그 하기 어렵고 등등) (분할, 균형, 데이터 의존) 

데이터 병렬은 (데이터는 다르나 일은 같은거고)

일 병렬(데이터는 같은데 일을 split)

이런 병렬성은 이분법적인게 아니라 병렬적이지 않은 부분이 성능을 좌우함 (이게 암달즈롤)

다대일 ( 간단하지만 하나가 멈추면 다 멈춤)

일대일( 하나 멈춰도 괜찮) 다만 오버헤드 발생가능성

다대다( 하나 멈춰도괜찮, 오버헤드 발생간으성 낮음)

쓰레드 라이브러리는 ( API 제공싸개)
 

1. thread Pool
2. fork-join
3. openMP (#으로시작)
4. grand central dispatch( js 활용) 

- 쓰레드 캔슬에는

비동기적 종료 ( 즉각종료)

연기 종료 (대기 했다가 자발적으로)
